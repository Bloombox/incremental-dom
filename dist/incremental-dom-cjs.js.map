{"version":3,"file":"incremental-dom-cjs.js","sources":["src/symbols.ts","src/util.ts","src/attributes.ts","src/global.ts","src/assertions.ts","src/notifications.ts","src/context.ts","src/dom_util.ts","src/node_data.ts","src/nodes.ts","src/core.ts","src/virtual_elements.ts","src/types.ts","index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst symbols = {\n  default: '__default'\n};\n\nexport {symbols,};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param map The map to check.\n * @param property The property to check.\n * @return Whether map has property.\n */\nfunction has(map: object, property: string): boolean {\n  return hasOwnProperty.call(map, property);\n}\n\n\n/**\n * Creates an map object without a prototype.\n */\n// tslint:disable-next-line:no-any\nfunction createMap(): any {\n  // tslint:disable-next-line:no-any\n  return new (Blank as any)();\n}\n\n\n/**\n * Truncates an array, removing items up until length.\n * @param arr The array to truncate.\n * @param length The new length of the array.\n */\nfunction truncateArray(arr: Array<{}|null|undefined>, length: number) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n}\n\nexport {createMap, has, truncateArray,};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {AttrMutatorConfig} from './types';\nimport {symbols} from './symbols';\nimport {createMap, has} from './util';\n\n\n/**\n * Returns the namespace to use for the attribute.\n */\nfunction getNamespace(name: string): string|undefined {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n\n  return undefined;\n}\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n */\n// tslint:disable-next-line:no-any\nfunction applyAttr(el: Element, name: string, value: any) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, String(value));\n    } else {\n      el.setAttribute(name, String(value));\n    }\n  }\n}\n\n/**\n * Applies a property to a given Element.\n */\n// tslint:disable-next-line:no-any\nfunction applyProp(el: Element, name: string, value: any) {\n  // tslint:disable-next-line:no-any\n  (el as any)[name] = value;\n}\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n */\nfunction setStyleValue(\n    style: CSSStyleDeclaration, prop: string, value: string) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, value);\n  } else {\n    // TODO(tomnguyen) Figure out why this is necessary.\n    // tslint:disable-next-line:no-any\n    (style as any)[prop] = value;\n  }\n}\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param el\n * @param name The attribute's name.\n * @param  style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nfunction applyStyle(\n    el: HTMLElement, name: string, style: string|{[k: string]: string}) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n\n    for (const prop in style) {\n      if (has(style, prop)) {\n        setStyleValue(elStyle, prop, style[prop]);\n      }\n    }\n  }\n}\n\n\n/**\n * Updates a single attribute on an Element.\n * @param el\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction applyAttributeTyped(el: HTMLElement, name: string, value: {}) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, value);\n  }\n}\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * NB: The result of createMap() has to be recast since closure compiler\n * will just assume attributes is \"any\" otherwise and throws away\n * the type annotation set by tsickle.\n */\nconst attributes: AttrMutatorConfig = (createMap() as AttrMutatorConfig);\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n */\nfunction updateAttribute(\n    el: HTMLElement, name: string, value: {}|null|undefined) {\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n}\n\n\n\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEBUG = true;\n\n/**\n * The name of the HTML attribute that holds the element key\n * (e.g. `<div key=\"foo\">`). The attribute value, if it exists, is then used\n * as the default key when importing an element.\n * If null, no attribute value is used as the default key.\n */\nlet keyAttributeName: string|null = 'key';\n\nfunction getKeyAttributeName() {\n  return keyAttributeName;\n}\n\nfunction setKeyAttributeName(name: string|null) {\n  keyAttributeName = name;\n}\n\nexport {\n  DEBUG,\n  getKeyAttributeName,\n  setKeyAttributeName,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DEBUG} from './global';\nimport {NameOrCtorDef} from './types';\n\n\n/**\n * Keeps track whether or not we are in an attributes declaration (after\n * elementOpenStart, but before elementOpenEnd).\n */\nlet inAttributes = false;\n\n\n/**\n * Keeps track whether or not we are in an element that should not have its\n * children cleared.\n */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n */\nfunction assertInPatch(functionName: string, context: Document) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n}\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param openElement\n * @param root\n */\nfunction assertNoUnclosedTags(\n    openElement: Node|null, root: Node|DocumentFragment) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags: string[] = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n}\n\n\n/**\n * Makes sure that node being outer patched has a parent node.\n */\nfunction assertPatchOuterHasParentNode(parent: Node|null) {\n  if (!parent) {\n    console.warn(\n      'patchOuter requires the node have a parent if there is a key.');\n  }\n}\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n */\nfunction assertNotInAttributes(functionName: string) {\n  if (inAttributes) {\n    throw new Error(\n        functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n}\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n */\nfunction assertNotInSkip(functionName: string) {\n  if (inSkip) {\n    throw new Error(\n        functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n}\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n */\nfunction assertInAttributes(functionName: string) {\n  if (!inAttributes) {\n    throw new Error(\n        functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n}\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nfunction assertVirtualAttributesClosed() {\n  if (inAttributes) {\n    throw new Error(\n        'elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n}\n\n\n/**\n * Makes sure that tags are correctly nested.\n */\nfunction assertCloseMatchesOpenTag(\n    currentNameOrCtor: NameOrCtorDef, nameOrCtor: NameOrCtorDef) {\n  if (currentNameOrCtor !== nameOrCtor) {\n    throw new Error(\n        'Received a call to close \"' + nameOrCtor + '\" but \"' +\n        currentNameOrCtor + '\" was open.');\n  }\n}\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n */\nfunction assertNoChildrenDeclaredYet(\n    functionName: string, previousNode: Node|null) {\n  if (previousNode !== null) {\n    throw new Error(\n        functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n}\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param maybeStartNode The value for the currentNode when the patch\n *     started.\n * @param currentNode The currentNode when the patch finished.\n * @param expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param  expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nfunction assertPatchElementNoExtras(\n    maybeStartNode: Node|null, maybeCurrentNode: Node|null,\n    expectedNextNode: Node|null, expectedPrevNode: Node|null) {\n  assert(maybeStartNode);\n  const startNode = maybeStartNode!;\n  // tslint:disable-next-line:no-unnecessary-type-assertion\n  const currentNode = maybeCurrentNode!;\n  const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n      currentNode.previousSibling === expectedPrevNode;\n  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n      currentNode.previousSibling === expectedPrevNode;\n  const wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error(\n        'There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n}\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @return the previous value.\n */\nfunction setInAttributes(value: boolean) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n}\n\n\n/**\n * Updates the state of being in a skip element.\n * @return the previous value.\n */\nfunction setInSkip(value: boolean) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n}\n\n/**\n * Asserts that a value exists and is not null or undefined. goog.asserts\n * is not used in order to avoid dependencies on external code.\n */\nfunction assert<T extends {}>(val: T|null|undefined): T {\n  if (DEBUG && !val) {\n    throw new Error('Expected value to be defined');\n  }\n  return val!;\n}\n\n\nexport {\n  assert,\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNoExtras,\n  assertPatchOuterHasParentNode,\n  setInAttributes,\n  setInSkip,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nexport type NodeFunction = (n: Node[]) => void;\n\nexport interface Notifications {\n  /**\n   * Called after patch has completed with any Nodes that have been created\n   * and added to the DOM.\n   */\n  nodesCreated: NodeFunction|null;\n  /**\n   * Called after patch has completed with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an application's responsibility to handle any childNodes.\n   */\n  nodesDeleted: NodeFunction|null;\n}\n\nexport const notifications: Notifications = {\n  nodesCreated: null,\n  nodesDeleted: null\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {notifications} from './notifications';\n\n\n/**\n * A context object keeps track of the state of a patch.\n */\nclass Context {\n  private created: Node[] = [];\n  private deleted: Node[] = [];\n\n  markCreated(node: Node) {\n    this.created.push(node);\n  }\n\n  markDeleted(node: Node) {\n    this.deleted.push(node);\n  }\n\n\n  /**\n   * Notifies about nodes that were created during the patch operation.\n   */\n  notifyChanges() {\n    if (notifications.nodesCreated && this.created.length > 0) {\n      notifications.nodesCreated(this.created);\n    }\n\n    if (notifications.nodesDeleted && this.deleted.length > 0) {\n      notifications.nodesDeleted(this.deleted);\n    }\n  }\n}\n\n\nexport {\n  Context,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Checks if the node is the root of a document. This is either a Document\n * or ShadowRoot. DocumentFragments are included for simplicity of the\n * implementation, though we only want to consider Documents or ShadowRoots.\n * @param node The node to check.\n * @return True if the node the root of a document, false otherwise.\n */\nfunction isDocumentRoot(node: Node): node is Document|ShadowRoot {\n  return node.nodeType === 11 || node.nodeType === 9;\n}\n\n/**\n * Checks if the node is an Element. This is faster than an instanceof check.\n * @param node The node to check.\n * @return Whether or not the node is an Element.\n */\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === 1;\n}\n\n\n/**\n * Checks if the node is a text node. This is faster than an instanceof check.\n * @param node The node to check.\n * @return Whether or not the node is a Text.\n */\nfunction isText(node: Node): node is Text {\n  return node.nodeType === 3;\n}\n\n/**\n * @param  node The node to start at, inclusive.\n * @param  root The root ancestor to get until, exclusive.\n * @return The ancestry of DOM nodes.\n */\nfunction getAncestry(node: Node, root: Node|null) {\n  const ancestry: Node[] = [];\n  let cur: Node|null = node;\n\n  while (cur !== root) {\n    const n: Node = cur!;\n    ancestry.push(n);\n    cur = n.parentNode;\n  }\n\n  return ancestry;\n}\n\n/**\n * return The root node of the DOM tree that contains this node.\n */\nconst getRootNode =\n    // tslint:disable-next-line:no-any b/79476176\n    (Node as any).prototype.getRootNode || function(this: Node) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion b/77361044\n      let cur: Node|null = this as Node;\n      let prev = cur;\n\n      while (cur) {\n        prev = cur;\n        cur = cur.parentNode;\n      }\n\n      return prev;\n    };\n\n\n/**\n * @param node The node to get the activeElement for.\n * @return The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nfunction getActiveElement(node: Node): Element|null {\n  const root = getRootNode.call(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n}\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param node The reference node to get the activeElement for.\n * @param root The root to get the focused path until.\n */\nfunction getFocusedPath(node: Node, root: Node|null): Node[] {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n}\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param parentNode\n * @param node\n * @param referenceNode\n */\nfunction moveBefore(parentNode: Node, node: Node, referenceNode: Node|null) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== null && cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n}\n\n\nexport {\n  isElement,\n  isText,\n  getFocusedPath,\n  moveBefore,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assert} from './assertions';\nimport {isElement, isText} from './dom_util';\nimport {getKeyAttributeName} from './global';\nimport {Key, NameOrCtorDef} from './types';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n */\nexport class NodeData {\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   */\n  // tslint:disable-next-line:no-any\n  private _attrsArr: null|any[] = null;\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   */\n  staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   */\n  key: Key;\n\n  text: string|undefined;\n\n  /**\n   * The nodeName or contructor for the Node.\n   */\n  readonly nameOrCtor: NameOrCtorDef;\n\n  constructor(nameOrCtor: NameOrCtorDef, key: Key, text: string|undefined) {\n    this.nameOrCtor = nameOrCtor;\n    this.key = key;\n    this.text = text;\n  }\n\n  hasEmptyAttrsArr(): boolean {\n    const attrs = this._attrsArr;\n    return !attrs || !attrs.length;\n  }\n\n  getAttrsArr(length: number): any[] {\n    return this._attrsArr || (this._attrsArr = new Array(length));\n  }\n}\n\ndeclare global {\n  interface Node {\n    '__incrementalDOMData': NodeData|null;\n  }\n}\n\n/**\n * Initializes a NodeData object for a Node.\n */\nfunction initData(\n    node: Node, nameOrCtor: NameOrCtorDef, key: Key,\n    text?: string|undefined): NodeData {\n  const data = new NodeData(nameOrCtor, key, text);\n  node['__incrementalDOMData'] = data;\n  return data;\n}\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n */\nfunction getData(node: Node, key?: Key) {\n  return importSingleNode(node, key);\n}\n\nfunction isDataInitialized(node: Node): boolean {\n  return Boolean(node['__incrementalDOMData']);\n}\n\nfunction getKey(node: Node) {\n  assert(node['__incrementalDOMData']);\n  return getData(node).key;\n}\n\n/**\n * Imports single node and its subtree, initializing caches.\n */\nfunction importSingleNode(node: Node, fallbackKey?: Key) {\n  if (node['__incrementalDOMData']) {\n    return node['__incrementalDOMData']!;\n  }\n\n  const nodeName = isElement(node) ? node.localName : node.nodeName;\n  const keyAttrName = getKeyAttributeName();\n  const keyAttr = isElement(node) && keyAttrName != null ?\n      node.getAttribute(keyAttrName) :\n      null;\n  const key = isElement(node) ? keyAttr || fallbackKey : null;\n  const data = initData(node, nodeName!, key);\n\n  if (isElement(node)) {\n    recordAttributes(node, data);\n  }\n\n  return data;\n}\n\n/**\n * Imports node and its subtree, initializing caches.\n */\nfunction importNode(node: Node) {\n  importSingleNode(node);\n\n  for (let child: Node|null = node.firstChild; child;\n       child = child.nextSibling) {\n    importNode(child);\n  }\n}\n\n/**\n * Clears all caches from a node and all of its children.\n */\nfunction clearCache(node: Node) {\n  node['__incrementalDOMData'] = null;\n\n  for (let child: Node|null = node.firstChild; child;\n       child = child.nextSibling) {\n    clearCache(child);\n  }\n}\n\n/**\n * Records the element's attributes.\n * @param node The Element that may have attributes\n * @param data The Element's data\n */\nfunction recordAttributes(node: Element, data: NodeData) {\n  const attributes = node.attributes;\n  const length = attributes.length;\n  if (!length) {\n    return;\n  }\n\n  const attrsArr = data.getAttrsArr(length);\n\n  // Use a cached length. The attributes array is really a live NamedNodeMap,\n  // which exists as a DOM \"Host Object\" (probably as C++ code). This makes the\n  // usual constant length iteration very difficult to optimize in JITs.\n  for (let i = 0, j = 0; i < length; i += 1, j += 2) {\n    const attr = attributes[i];\n    const name = attr.name;\n    const value = attr.value;\n\n    attrsArr[j] = name;\n    attrsArr[j + 1] = value;\n  }\n}\n\n\n/** */\nexport {\n  getData,\n  getKey,\n  initData,\n  importNode,\n  isDataInitialized,\n  clearCache,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getData, initData} from './node_data';\nimport {Key, NameOrCtorDef} from './types';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n */\nfunction getNamespaceForTag(tag: string, parent: Node|null) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n  \n  if (tag === 'math') {\n    return 'http://www.w3.org/1998/Math/MathML';\n  }\n\n  if (parent == null) {\n    return null;\n  }\n\n  if (getData(parent).nameOrCtor === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n}\n\n\n/**\n * Creates an Element.\n * @param doc The document with which to create the Element.\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key A key to identify the Element.\n * @param  typeId The type identifier for the Element.\n */\nfunction createElement(\n    doc: Document, parent: Node|null, nameOrCtor: NameOrCtorDef, key: Key)\n    : Element {\n  let el;\n\n  if (typeof nameOrCtor === 'function') {\n    el = new nameOrCtor();\n  } else {\n    const namespace = getNamespaceForTag(nameOrCtor, parent);\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, nameOrCtor);\n    } else {\n      el = doc.createElement(nameOrCtor);\n    }\n  }\n\n  initData(el, nameOrCtor, key);\n\n  return el;\n}\n\n\n/**\n * Creates a Text Node.\n * @param doc The document with which to create the Element.\n * @return\n */\nfunction createText(doc: Document) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n}\n\n\n/** */\nexport {\n  createElement,\n  createText,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assertInPatch, assertNoChildrenDeclaredYet, assertNotInAttributes, assertNoUnclosedTags, assertPatchElementNoExtras, assertPatchOuterHasParentNode, assertVirtualAttributesClosed, setInAttributes, setInSkip} from './assertions';\nimport {Context} from './context';\nimport {getFocusedPath, moveBefore} from './dom_util';\nimport {DEBUG} from './global';\nimport {getData} from './node_data';\nimport {createElement, createText} from './nodes';\nimport {Key, MatchFnDef, NameOrCtorDef, PatchConfig, PatchFunction} from './types';\n\nlet context: Context|null = null;\n\nlet currentNode: Node|null = null;\n\nlet currentParent: Node|null = null;\n\nlet doc: Document|null = null;\n\nlet focusPath: Array<Node> = [];\n\nlet matchFn: MatchFnDef = defaultMatchFn;\n\n/**\n * Used to build up call arguments. Each patch call gets a separate copy, so\n * this works with nested calls to patch.\n */\nlet argsBuilder: Array<{}|null|undefined> = [];\n\n/**\n * TODO(sparhami) We should just export argsBuilder directly when Closure\n * Compiler supports ES6 directly.\n */\nfunction getArgsBuilder(): Array<{}|null|undefined>{\n  return argsBuilder;\n}\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n */\nfunction createPatcher<T, R>(\n    run: PatchFunction<T, R>,\n    patchConfig: PatchConfig = {},\n): PatchFunction<T, R> {\n  const {\n    matches = defaultMatchFn,\n  } = patchConfig;\n\n  const f: PatchFunction<T, R> = (node, fn, data) => {\n    const prevContext = context;\n    const prevDoc = doc;\n    const prevFocusPath = focusPath;\n    const prevArgsBuilder = argsBuilder;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    const prevMatchFn = matchFn;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    doc = node.ownerDocument;\n    context = new Context();\n    matchFn = matches;\n    argsBuilder = [];\n    currentNode = null;\n    currentParent = node.parentNode;\n    focusPath = getFocusedPath(node, currentParent);\n\n    if (DEBUG) {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    try {\n      const retVal = run(node, fn, data);\n      if (DEBUG) {\n        assertVirtualAttributesClosed();\n      }\n\n      return retVal;\n    } finally {\n      argsBuilder = prevArgsBuilder;\n      currentNode = prevCurrentNode;\n      currentParent = prevCurrentParent;\n      focusPath = prevFocusPath;\n      context.notifyChanges();\n\n      // Needs to be done after assertions because assertions rely on state\n      // from these methods.\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n      doc = prevDoc;\n      context = prevContext;\n      matchFn = prevMatchFn;\n    }\n  };\n  return f;\n}\n\n\n/**\n * Creates a patcher that patches the document starting at node with a\n * provided function. This function may be called during an existing patch operation.\n */\nfunction createPatchInner<T>(patchConfig?: PatchConfig):\n    PatchFunction<T, Node> {\n  return createPatcher((node, fn, data) => {\n    currentNode = node;\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if (DEBUG) {\n      assertNoUnclosedTags(currentNode, node);\n    }\n\n    return node;\n  }, patchConfig);\n}\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n */\nfunction createPatchOuter<T>(patchConfig?: PatchConfig):\n    PatchFunction<T, Node|null> {\n  return createPatcher((node, fn, data) => {\n    // tslint:disable-next-line:no-any\n    const startNode = (({nextSibling: node}) as any) as Element;\n    let expectedNextNode: Node|null = null;\n    let expectedPrevNode: Node|null = null;\n\n    if (DEBUG) {\n      expectedNextNode = node.nextSibling;\n      expectedPrevNode = node.previousSibling;\n    }\n\n    currentNode = startNode;\n    fn(data);\n\n    if (DEBUG) {\n      assertPatchOuterHasParentNode(currentParent);\n      assertPatchElementNoExtras(\n          startNode, currentNode, expectedNextNode, expectedPrevNode);\n    }\n\n    if (currentParent) {\n      clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);\n    }\n\n    return (startNode === currentNode) ? null : currentNode;\n  }, patchConfig);\n}\n\n\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key. This uses the specified match function when creating the patcher.\n * @param matchNode A node to match the data to.\n * @param nameOrCtor The name or constructor to check for.\n * @param key The key used to identify the Node.\n * @return True if the node matches, false otherwise.\n */\nfunction matches(\n    matchNode: Node, nameOrCtor: NameOrCtorDef, key: Key): boolean {\n  const data = getData(matchNode, key);\n\n  return matchFn(matchNode, nameOrCtor, data.nameOrCtor, key, data.key);\n}\n\n\n/**\n * The default match function to use, if one was not specified when creating\n * the patcher.\n * @param matchNode The node to match against, unused.\n * @param nameOrCtor The name or constructor as declared.\n * @param expectedNameOrCtor The name or constructor of the existing node.\n * @param key The key as declared.\n * @param expectedKey The key of the existing node.\n */\nfunction defaultMatchFn(\n    matchNode: Node,\n    nameOrCtor: NameOrCtorDef,\n    expectedNameOrCtor: NameOrCtorDef,\n    key: Key,\n    expectedKey: Key,\n): boolean {\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  // tslint:disable-next-line:triple-equals\n  return nameOrCtor == expectedNameOrCtor && key == expectedKey;\n}\n\n\n/**\n * Finds the matching node, starting at `node` and looking at the subsequent\n * siblings if a key is used.\n * @param node The node to start looking at.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction getMatchingNode(\n    matchNode: Node|null, nameOrCtor: NameOrCtorDef, key: Key): Node|null {\n  if (!matchNode) {\n    return null;\n  }\n\n  if (matches(matchNode, nameOrCtor, key)) {\n    return matchNode;\n  }\n\n  if (key) {\n    while ((matchNode = matchNode.nextSibling)) {\n      if (matches(matchNode, nameOrCtor, key)) {\n        return matchNode;\n      }\n    }\n  }\n\n  return null;\n}\n\n\n/**\n * Creates a Node and marking it as created.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @return The newly created node.\n */\nfunction createNode(nameOrCtor: NameOrCtorDef, key:Key): Node {\n  let node;\n\n  if (nameOrCtor === '#text') {\n    node = createText(doc!);\n  } else {\n    node = createElement(doc!, currentParent!, nameOrCtor, key);\n  }\n\n  context!.markCreated(node);\n\n  return node;\n}\n\n\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction alignWithDOM(nameOrCtor: NameOrCtorDef, key: Key) {\n  nextNode();\n  const existingNode = getMatchingNode(currentNode, nameOrCtor, key);\n  const node = existingNode || createNode(nameOrCtor, key);\n\n  // If we are at the matching node, then we are done.\n  if (node === currentNode) {\n    return;\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (focusPath.indexOf(node) >= 0) {\n    // Move everything else before the node.\n    moveBefore(currentParent!, node, currentNode);\n  } else {\n    currentParent!.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n}\n\n\n/**\n * Clears out any unvisited Nodes in a given range.\n * @param maybeParentNode\n * @param startNode The node to start clearing from, inclusive.\n * @param endNode The node to clear until, exclusive.\n */\nfunction clearUnvisitedDOM(\n    maybeParentNode: Node|null, startNode: Node|null, endNode: Node|null) {\n  const parentNode = maybeParentNode!;\n  let child = startNode;\n\n  while (child !== endNode) {\n    const next = child!.nextSibling;\n    parentNode.removeChild(child!);\n    context!.markDeleted(child!);\n    child = next;\n  }\n}\n\n\n/**\n * Changes to the first child of the current node.\n */\nfunction enterNode() {\n  currentParent = currentNode;\n  currentNode = null;\n}\n\n\n/**\n * @return The next Node to be patched.\n */\nfunction getNextNode(): Node|null {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent!.firstChild;\n  }\n}\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nfunction nextNode() {\n  currentNode = getNextNode();\n}\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nfunction exitNode() {\n  clearUnvisitedDOM(currentParent, getNextNode(), null);\n\n  currentNode = currentParent;\n  currentParent = currentParent!.parentNode;\n}\n\n\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return The corresponding Element.\n */\nfunction open(nameOrCtor: NameOrCtorDef, key?: Key): HTMLElement {\n  alignWithDOM(nameOrCtor, key);\n  enterNode();\n  return (currentParent as HTMLElement);\n}\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n */\nfunction close() {\n  if (DEBUG) {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (currentNode) as Element;\n}\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n */\nfunction text(): Text {\n  alignWithDOM('#text', null);\n  return (currentNode) as Text;\n}\n\n\n/**\n * Gets the current Element being patched.\n */\nfunction currentElement(): HTMLElement {\n  if (DEBUG) {\n    assertInPatch('currentElement', doc!);\n    assertNotInAttributes('currentElement');\n  }\n  return (currentParent) as HTMLElement;\n}\n\n\n/**\n * @return The Node that will be evaluated for the next instruction.\n */\nfunction currentPointer(): Node {\n  if (DEBUG) {\n    assertInPatch('currentPointer', doc!);\n    assertNotInAttributes('currentPointer');\n  }\n  // TODO(tomnguyen): assert that this is not null\n  return getNextNode()!;\n}\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nfunction skip() {\n  if (DEBUG) {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent!.lastChild;\n}\n\n\nconst patchInner = createPatchInner();\nconst patchOuter = createPatchOuter();\n\n/** */\nexport {\n  alignWithDOM,\n  getArgsBuilder,\n  text,\n  createPatchInner,\n  createPatchOuter,\n  patchInner,\n  patchOuter,\n  open,\n  close,\n  currentElement,\n  currentPointer,\n  skip,\n  nextNode as skipNode,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {assert, assertCloseMatchesOpenTag, assertInAttributes, assertNotInAttributes, assertNotInSkip, setInAttributes} from './assertions';\nimport {updateAttribute} from './attributes';\nimport {getArgsBuilder, close, open, text as coreText} from './core';\nimport {DEBUG} from './global';\nimport {getData, NodeData} from './node_data';\nimport {Key, NameOrCtorDef, Statics} from './types';\nimport {createMap, truncateArray} from './util';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is reused.\n * TODO(sparhamI) Scope this to a patch so you can call patch from an attribute\n * update.\n */\nconst prevAttrsMap = createMap();\n\n\n/**\n * Applies the statics. When importing an Element, any existing attributes that\n * match a static are converted into a static attribute.\n * @param node The Element to apply statics for.\n * @param data The Element's data\n * @param statics The statics array,\n */\nfunction applyStatics(node: HTMLElement, data: NodeData, statics: Statics) {\n  data.staticsApplied = true;\n\n  if (!statics || !statics.length) {\n    return;\n  }\n\n  if (data.hasEmptyAttrsArr()) {\n    for (let i = 0; i < statics.length; i += 2) {\n      updateAttribute(node, statics[i] as string, statics[i + 1]);\n    }\n    return;\n  }\n\n  for (let i = 0; i < statics.length; i += 2) {\n    prevAttrsMap[statics[i] as string] = i + 1;\n  }\n\n  const attrsArr = data.getAttrsArr(0);\n  let j = 0;\n  for (let i = 0; i < attrsArr.length; i += 2) {\n    const name = attrsArr[i];\n    const value = attrsArr[i + 1];\n    const staticsIndex = prevAttrsMap[name];\n\n    if (staticsIndex) {\n      // For any attrs that are static and have the same value, make sure we do\n      // not set them again.\n      if (statics[staticsIndex] === value) {\n        delete prevAttrsMap[name];\n      }\n\n      continue;\n    }\n\n    // For any attrs that are dynamic, move them up to the right place.\n    attrsArr[j] = name;\n    attrsArr[j + 1] = value;\n    j += 2;\n  }\n  // Anything after `j` was either moved up already or static.\n  truncateArray(attrsArr, j);\n\n  for (const name in prevAttrsMap) {\n    updateAttribute(node, name, statics[prevAttrsMap[name]]);\n    delete prevAttrsMap[name];\n  }\n}\n\n\n/**\n * @param  nameOrCtor The Element's tag or constructor.\n * @param  key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementOpen(\n    nameOrCtor: NameOrCtorDef, key?: Key,\n    // Ideally we could tag statics and varArgs as an array where every odd\n    // element is a string and every even element is any, but this is hard.\n    // tslint:disable-next-line:no-any\n    statics?: Statics, ...varArgs: any[]) {\n  if (DEBUG) {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = open(nameOrCtor, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    applyStatics(node, data, statics);\n  }\n\n  const attrsLength = Math.max(0, arguments.length - ATTRIBUTES_OFFSET);\n  const hadNoAttrs = data.hasEmptyAttrsArr();\n\n  if (!attrsLength && hadNoAttrs) {\n    return node;\n  }\n\n  const attrsArr = data.getAttrsArr(attrsLength);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const name = arguments[i];\n    if (hadNoAttrs) {\n      attrsArr[j] = name;\n    } else if (attrsArr[j] !== name) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (hadNoAttrs || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, name, value);\n    }\n  }\n\n  /*\n   * Items did not line up exactly as before, need to make sure old items are\n   * removed. This can happen if using conditional logic when declaring\n   * attrs through the elementOpenStart flow or if one element is reused in\n   * the place of another.\n   */\n  if (i < arguments.length || j < attrsArr.length) {\n    const attrsStart = j;\n\n    for (; j < attrsArr.length; j += 2) {\n      prevAttrsMap[attrsArr[j]] = attrsArr[j + 1];\n    }\n\n    for (j = attrsStart; i < arguments.length; i += 2, j += 2) {\n      const name = arguments[i];\n      const value = arguments[i + 1];\n\n      if (prevAttrsMap[name] !== value) {\n        updateAttribute(node, name, value);\n      }\n\n      attrsArr[j] = name;\n      attrsArr[j + 1] = value;\n\n      delete prevAttrsMap[name];\n    }\n\n    truncateArray(attrsArr, j);\n\n    /*\n     * At this point, only have attributes that were present before, but have\n     * been removed.\n     */\n    for (const name in prevAttrsMap) {\n      updateAttribute(node, name, undefined);\n      delete prevAttrsMap[name];\n    }\n  }\n\n  return node;\n}\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n */\nfunction elementOpenStart(\n  nameOrCtor: NameOrCtorDef, key?: Key, statics?: Statics) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n}\n\n\n/**\n * Allows you to define a key after an elementOpenStart. This is useful in\n * templates that define key after an element has been opened ie\n * `<div key('foo')></div>`.\n */\nfunction key(key:string) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('key');\n    assert(argsBuilder);\n  }\n  argsBuilder[1] = key;\n}\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n */\n// tslint:disable-next-line:no-any\nfunction attr(name: string, value: any) {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n}\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return The corresponding Element.\n */\nfunction elementOpenEnd(): HTMLElement {\n  const argsBuilder = getArgsBuilder();\n\n  if (DEBUG) {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  assert(argsBuilder);\n  const node = elementOpen.apply(null, argsBuilder!);\n  truncateArray(argsBuilder, 0);\n  return node;\n}\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param nameOrCtor The Element's tag or constructor.\n * @return The corresponding Element.\n */\nfunction elementClose(nameOrCtor: NameOrCtorDef): Element {\n  if (DEBUG) {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = close();\n\n  if (DEBUG) {\n    assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n  }\n\n  return node;\n}\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementVoid(\n    nameOrCtor: NameOrCtorDef, key?: Key,\n    // Ideally we could tag statics and varArgs as an array where every odd\n    // element is a string and every even element is any, but this is hard.\n    // tslint:disable-next-line:no-any\n    statics?: Statics, ...varArgs: any[]) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n}\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param value The value of the Text.\n * @param varArgs\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return The corresponding text node.\n */\nfunction text(value: string|number|boolean, ...varArgs: Array<(a: {}) => string>) {\n  if (DEBUG) {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = (value) as string;\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    // Setting node.data resets the cursor in IE/Edge.\n    if (node.data !== formatted) {\n      node.data = formatted as string;\n    }\n  }\n\n  return node;\n}\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr,\n  key,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ElementConstructor {new(): Element};\n\n// tslint:disable-next-line:no-any\nexport type AttrMutator = (a: HTMLElement, b: string, c: any) => void;\n\nexport type AttrMutatorConfig = {[x: string]: AttrMutator};\n\nexport type NameOrCtorDef = string|ElementConstructor;\n\nexport type Key = string|number|null|undefined;\n\nexport type Statics = Array<{}>|null|undefined;\n\nexport type PatchFunction<T, R> = (\n    node: Element|DocumentFragment,\n    template: (a: T|undefined) => void,\n    data?: T|undefined\n) => R;\n\nexport type MatchFnDef = (\n    matchNode: Node,\n    nameOrCtor: NameOrCtorDef,\n    expectedNameOrCtor: NameOrCtorDef,\n    key: Key,\n    expectedKey: Key\n) =>  boolean;\n\nexport type PatchConfig = {\n  matches?: MatchFnDef,\n};\n","/**\n * @license\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport {applyAttr, applyProp, attributes,} from './src/attributes';\nexport {alignWithDOM, close, createPatchInner, createPatchOuter, currentElement, currentPointer, open, patchInner as patch, patchInner, patchOuter, skip, skipNode} from './src/core';\nexport {setKeyAttributeName} from './src/global';\nexport {clearCache,getKey, importNode, isDataInitialized} from './src/node_data';\nexport {notifications} from './src/notifications';\nexport {symbols} from './src/symbols';\nexport {attr, elementClose, elementOpen, elementOpenEnd, elementOpenStart, elementVoid, key, text} from './src/virtual_elements';\nexport * from './src/types';\n"],"names":["symbols","hasOwnProperty","Object","prototype","Blank","create","map","property","call","arr","length","pop","name","lastIndexOf","undefined","el","value","removeAttribute","attrNS","getNamespace","setAttributeNS","String","setAttribute","style","prop","indexOf","setProperty","cssText","elStyle","has","type","attributes","createMap","default","applyAttributeTyped","applyStyle","mutator","DEBUG","keyAttributeName","inAttributes","inSkip","functionName","context","Error","openElement","root","currentElement","openTags","push","nodeName","toLowerCase","parentNode","join","parent","warn","currentNameOrCtor","nameOrCtor","previousNode","maybeStartNode","maybeCurrentNode","expectedNextNode","expectedPrevNode","startNode","currentNode","wasUpdated","nextSibling","previousSibling","wasChanged","wasRemoved","previous","val","notifications","node","created","deleted","nodesCreated","nodesDeleted","nodeType","ancestry","cur","n","getRootNode","Node","prev","isDocumentRoot","activeElement","getActiveElement","contains","getAncestry","referenceNode","insertReferenceNode","next","insertBefore","key","text","attrs","_attrsArr","Array","data","NodeData","importSingleNode","Boolean","getData","fallbackKey","isElement","localName","keyAttrName","getKeyAttributeName","keyAttr","getAttribute","initData","child","firstChild","attrsArr","getAttrsArr","i","j","attr","tag","namespaceURI","doc","namespace","getNamespaceForTag","createElementNS","createElement","createTextNode","currentParent","focusPath","matchFn","defaultMatchFn","argsBuilder","run","patchConfig","_a","matches","f","fn","prevContext","prevDoc","prevFocusPath","prevArgsBuilder","prevCurrentNode","prevCurrentParent","prevMatchFn","previousInAttributes","previousInSkip","ownerDocument","Context","getFocusedPath","setInAttributes","setInSkip","retVal","notifyChanges","createPatcher","getNextNode","matchNode","expectedNameOrCtor","expectedKey","createText","markCreated","existingNode","getMatchingNode","createNode","maybeParentNode","endNode","removeChild","markDeleted","lastChild","patchInner","createPatchInner","patchOuter","createPatchOuter","ATTRIBUTES_OFFSET","prevAttrsMap","statics","staticsApplied","hasEmptyAttrsArr","staticsIndex","_i","open","attrsLength","Math","max","arguments","hadNoAttrs","attrsStart","getArgsBuilder","elementOpen","apply","close","elementClose","coreText","formatted"],"mappings":"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","sourceRoot":"/source/"}