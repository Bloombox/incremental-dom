/**
 * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { truncateArray } from "./util";
const buffer = [];
let bufferStart = 0;
/**
 * TODO(tomnguyen): This is a bit silly and really needs to be better typed.
 * @param fn A function to call.
 * @param a The first argument to the function.
 * @param b The second argument to the function.
 * @param c The third argument to the function.
 */
function queueChange(fn, a, b, c) {
    buffer.push(fn);
    buffer.push(a);
    buffer.push(b);
    buffer.push(c);
}
/**
 * Flushes the changes buffer, calling the functions for each change.
 */
function flush() {
    // A change may cause this function to be called re-entrantly. Keep track of
    // the portion of the buffer we are consuming. Updates the start pointer so
    // that the next call knows where to start from.
    const start = bufferStart;
    const end = buffer.length;
    bufferStart = end;
    for (let i = start; i < end; i += 4) {
        const fn = buffer[i];
        fn(buffer[i + 1], buffer[i + 2], buffer[i + 3]);
    }
    bufferStart = start;
    truncateArray(buffer, start);
}
export { queueChange, flush };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbmdlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3JlbGVhc2UvY2hhbmdlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUVILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFdkMsTUFBTSxNQUFNLEdBQWUsRUFBRSxDQUFDO0FBRTlCLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztBQUVwQjs7Ozs7O0dBTUc7QUFDSCxTQUFTLFdBQVcsQ0FDbEIsRUFBOEIsRUFDOUIsQ0FBSSxFQUNKLENBQUksRUFDSixDQUFJO0lBRUosTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNoQixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2YsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNmLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxLQUFLO0lBQ1osNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSxnREFBZ0Q7SUFDaEQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDO0lBQzFCLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFFMUIsV0FBVyxHQUFHLEdBQUcsQ0FBQztJQUVsQixLQUFLLElBQUksQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDbkMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBMEMsQ0FBQztRQUM5RCxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNqRDtJQUVELFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDcEIsYUFBYSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBRUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTggVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgdHJ1bmNhdGVBcnJheSB9IGZyb20gXCIuL3V0aWxcIjtcblxuY29uc3QgYnVmZmVyOiBBcnJheTxhbnk+ID0gW107XG5cbmxldCBidWZmZXJTdGFydCA9IDA7XG5cbi8qKlxuICogVE9ETyh0b21uZ3V5ZW4pOiBUaGlzIGlzIGEgYml0IHNpbGx5IGFuZCByZWFsbHkgbmVlZHMgdG8gYmUgYmV0dGVyIHR5cGVkLlxuICogQHBhcmFtIGZuIEEgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBjIFRoZSB0aGlyZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQ2hhbmdlPEEsIEIsIEM+KFxuICBmbjogKGE6IEEsIGI6IEIsIGM6IEMpID0+IHZvaWQsXG4gIGE6IEEsXG4gIGI6IEIsXG4gIGM6IENcbikge1xuICBidWZmZXIucHVzaChmbik7XG4gIGJ1ZmZlci5wdXNoKGEpO1xuICBidWZmZXIucHVzaChiKTtcbiAgYnVmZmVyLnB1c2goYyk7XG59XG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY2hhbmdlcyBidWZmZXIsIGNhbGxpbmcgdGhlIGZ1bmN0aW9ucyBmb3IgZWFjaCBjaGFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAvLyBBIGNoYW5nZSBtYXkgY2F1c2UgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgcmUtZW50cmFudGx5LiBLZWVwIHRyYWNrIG9mXG4gIC8vIHRoZSBwb3J0aW9uIG9mIHRoZSBidWZmZXIgd2UgYXJlIGNvbnN1bWluZy4gVXBkYXRlcyB0aGUgc3RhcnQgcG9pbnRlciBzb1xuICAvLyB0aGF0IHRoZSBuZXh0IGNhbGwga25vd3Mgd2hlcmUgdG8gc3RhcnQgZnJvbS5cbiAgY29uc3Qgc3RhcnQgPSBidWZmZXJTdGFydDtcbiAgY29uc3QgZW5kID0gYnVmZmVyLmxlbmd0aDtcblxuICBidWZmZXJTdGFydCA9IGVuZDtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gNCkge1xuICAgIGNvbnN0IGZuID0gYnVmZmVyW2ldIGFzIChhOiBhbnksIGI6IGFueSwgYzogYW55KSA9PiB1bmRlZmluZWQ7XG4gICAgZm4oYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSwgYnVmZmVyW2kgKyAzXSk7XG4gIH1cblxuICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICB0cnVuY2F0ZUFycmF5KGJ1ZmZlciwgc3RhcnQpO1xufVxuXG5leHBvcnQgeyBxdWV1ZUNoYW5nZSwgZmx1c2ggfTtcbiJdfQ==