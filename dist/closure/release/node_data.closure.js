/**
 * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { assert } from "./assertions";
import { createArray } from "./util";
import { isElement } from "./dom_util";
import { getKeyAttributeName } from "./global";
/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 */
export class NodeData {
    constructor(nameOrCtor, key, text) {
        /**
         * An array of attribute name/value pairs, used for quickly diffing the
         * incomming attributes to see if the DOM node's attributes need to be
         * updated.
         */
        this._attrsArr = null;
        /**
         * Whether or not the statics have been applied for the node yet.
         */
        this.staticsApplied = false;
        this.nameOrCtor = nameOrCtor;
        this.key = key;
        this.text = text;
    }
    hasEmptyAttrsArr() {
        const attrs = this._attrsArr;
        return !attrs || !attrs.length;
    }
    getAttrsArr(length) {
        return this._attrsArr || (this._attrsArr = createArray(length));
    }
}
/**
 * Initializes a NodeData object for a Node.
 * @param node The Node to initialized data for.
 * @param nameOrCtor The NameOrCtorDef to use when diffing.
 * @param key The Key for the Node.
 * @param text The data of a Text node, if importing a Text node.
 * @returns A NodeData object with the existing attributes initialized.
 */
function initData(node, nameOrCtor, key, text) {
    const data = new NodeData(nameOrCtor, key, text);
    node["__incrementalDOMData"] = data;
    return data;
}
/**
 * @param node The node to check.
 * @returns True if the NodeData already exists, false otherwise.
 */
function isDataInitialized(node) {
    return Boolean(node["__incrementalDOMData"]);
}
/**
 * Records the element's attributes.
 * @param node The Element that may have attributes
 * @param data The Element's data
 */
function recordAttributes(node, data) {
    const attributes = node.attributes;
    const length = attributes.length;
    if (!length) {
        return;
    }
    const attrsArr = data.getAttrsArr(length);
    // Use a cached length. The attributes array is really a live NamedNodeMap,
    // which exists as a DOM "Host Object" (probably as C++ code). This makes the
    // usual constant length iteration very difficult to optimize in JITs.
    for (let i = 0, j = 0; i < length; i += 1, j += 2) {
        const attr = attributes[i];
        const name = attr.name;
        const value = attr.value;
        attrsArr[j] = name;
        attrsArr[j + 1] = value;
    }
}
/**
 * Imports single node and its subtree, initializing caches, if it has not
 * already been imported.
 * @param node The node to import.
 * @param fallbackKey A key to use if importing and no key was specified.
 *    Useful when not transmitting keys from serverside render and doing an
 *    immediate no-op diff.
 * @returns The NodeData for the node.
 */
function importSingleNode(node, fallbackKey) {
    if (node["__incrementalDOMData"]) {
        return node["__incrementalDOMData"];
    }
    const nodeName = isElement(node) ? node.localName : node.nodeName;
    const keyAttrName = getKeyAttributeName();
    const keyAttr = isElement(node) && keyAttrName != null
        ? node.getAttribute(keyAttrName)
        : null;
    const key = isElement(node) ? keyAttr || fallbackKey : null;
    const data = initData(node, nodeName, key);
    if (isElement(node)) {
        recordAttributes(node, data);
    }
    return data;
}
/**
 * Imports node and its subtree, initializing caches.
 * @param node The Node to import.
 */
function importNode(node) {
    importSingleNode(node);
    for (let child = node.firstChild; child; child = child.nextSibling) {
        importNode(child);
    }
}
/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 * @param node The node to get data for.
 * @param fallbackKey A key to use if importing and no key was specified.
 *    Useful when not transmitting keys from serverside render and doing an
 *    immediate no-op diff.
 * @returns The NodeData for the node.
 */
function getData(node, fallbackKey) {
    return importSingleNode(node, fallbackKey);
}
/**
 * Gets the key for a Node. note that the Node should have been imported
 * by now.
 * @param node The node to check.
 * @returns The key used to create the node.
 */
function getKey(node) {
    assert(node["__incrementalDOMData"]);
    return getData(node).key;
}
/**
 * Clears all caches from a node and all of its children.
 * @param node The Node to clear the cache for.
 */
function clearCache(node) {
    node["__incrementalDOMData"] = null;
    for (let child = node.firstChild; child; child = child.nextSibling) {
        clearCache(child);
    }
}
export { getData, getKey, initData, importNode, isDataInitialized, clearCache };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9kYXRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcmVsZWFzZS9ub2RlX2RhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFHSCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDckMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUN2QyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFRL0M7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQTZCbkIsWUFDRSxVQUF5QixFQUN6QixHQUFRLEVBQ1IsSUFBd0I7UUEvQjFCOzs7O1dBSUc7UUFDSyxjQUFTLEdBQXNCLElBQUksQ0FBQztRQUU1Qzs7V0FFRztRQUNJLG1CQUFjLEdBQUcsS0FBSyxDQUFDO1FBdUI1QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFTSxnQkFBZ0I7UUFDckIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUM3QixPQUFPLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUNqQyxDQUFDO0lBRU0sV0FBVyxDQUFDLE1BQWM7UUFDL0IsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0NBQ0Y7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBUyxRQUFRLENBQ2YsSUFBVSxFQUNWLFVBQXlCLEVBQ3pCLEdBQVEsRUFDUixJQUF5QjtJQUV6QixNQUFN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aUI7SUFDNUMsT0FBTyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDN0MsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxNQUFNLENBQUMsSUFBVTtJQUN4QixNQUFNLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQztJQUNyQyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDM0IsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsVUFBVSxDQUFDLElBQVU7SUFDNUIsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsSUFBSSxDQUFDO0lBRXBDLEtBQ0UsSUFBSSxLQUFLLEdBQWdCLElBQUksQ0FBQyxVQUFVLEVBQ3hDLEtBQUssRUFDTCxLQUFLLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFDekI7UUFDQSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbkI7QUFDSCxDQUFDO0FBRUQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTggVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgS2V5LCBOYW1lT3JDdG9yRGVmIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydGlvbnNcIjtcbmltcG9ydCB7IGNyZWF0ZUFycmF5IH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tX3V0aWxcIjtcbmltcG9ydCB7IGdldEtleUF0dHJpYnV0ZU5hbWUgfSBmcm9tIFwiLi9nbG9iYWxcIjtcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgTm9kZSB7XG4gICAgX19pbmNyZW1lbnRhbERPTURhdGE6IE5vZGVEYXRhIHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIGluZm9ybWF0aW9uIG5lZWRlZCB0byBwZXJmb3JtIGRpZmZzIGZvciBhIGdpdmVuIERPTSBub2RlLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZURhdGEge1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMsIHVzZWQgZm9yIHF1aWNrbHkgZGlmZmluZyB0aGVcbiAgICogaW5jb21taW5nIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIHRoZSBET00gbm9kZSdzIGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgKiB1cGRhdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfYXR0cnNBcnI6IEFycmF5PGFueT4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHN0YXRpY3MgaGF2ZSBiZWVuIGFwcGxpZWQgZm9yIHRoZSBub2RlIHlldC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWNzQXBwbGllZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBub2RlLCB1c2VkIHRvIHByZXNlcnZlIERPTSBub2RlcyB3aGVuIHRoZXlcbiAgICogbW92ZSB3aXRoaW4gdGhlaXIgcGFyZW50LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGtleTogS2V5O1xuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgdGV4dCB2YWx1ZSwgZm9yIFRleHQgbm9kZXMuXG4gICAqL1xuICBwdWJsaWMgdGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgbm9kZU5hbWUgb3IgY29udHJ1Y3RvciBmb3IgdGhlIE5vZGUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZU9yQ3RvcjogTmFtZU9yQ3RvckRlZjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgbmFtZU9yQ3RvcjogTmFtZU9yQ3RvckRlZixcbiAgICBrZXk6IEtleSxcbiAgICB0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKSB7XG4gICAgdGhpcy5uYW1lT3JDdG9yID0gbmFtZU9yQ3RvcjtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG5cbiAgcHVibGljIGhhc0VtcHR5QXR0cnNBcnIoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLl9hdHRyc0FycjtcbiAgICByZXR1cm4gIWF0dHJzIHx8ICFhdHRycy5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0QXR0cnNBcnIobGVuZ3RoOiBudW1iZXIpOiBBcnJheTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNBcnIgfHwgKHRoaXMuX2F0dHJzQXJyID0gY3JlYXRlQXJyYXkobGVuZ3RoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIE5vZGVEYXRhIG9iamVjdCBmb3IgYSBOb2RlLlxuICogQHBhcmFtIG5vZGUgVGhlIE5vZGUgdG8gaW5pdGlhbGl6ZWQgZGF0YSBmb3IuXG4gKiBAcGFyYW0gbmFtZU9yQ3RvciBUaGUgTmFtZU9yQ3RvckRlZiB0byB1c2Ugd2hlbiBkaWZmaW5nLlxuICogQHBhcmFtIGtleSBUaGUgS2V5IGZvciB0aGUgTm9kZS5cbiAqIEBwYXJhbSB0ZXh0IFRoZSBkYXRhIG9mIGEgVGV4dCBub2RlLCBpZiBpbXBvcnRpbmcgYSBUZXh0IG5vZGUuXG4gKiBAcmV0dXJucyBBIE5vZGVEYXRhIG9iamVjdCB3aXRoIHRoZSBleGlzdGluZyBhdHRyaWJ1dGVzIGluaXRpYWxpemVkLlxuICovXG5mdW5jdGlvbiBpbml0RGF0YShcbiAgbm9kZTogTm9kZSxcbiAgbmFtZU9yQ3RvcjogTmFtZU9yQ3RvckRlZixcbiAga2V5OiBLZXksXG4gIHRleHQ/OiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IE5vZGVEYXRhIHtcbiAgY29uc3QgZGF0YSA9IG5ldyBOb2RlRGF0YShuYW1lT3JDdG9yLCBrZXksIHRleHQpO1xuICBub2RlW1wiX19pbmNyZW1lbnRhbERPTURhdGFcIl0gPSBkYXRhO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIE5vZGVEYXRhIGFscmVhZHkgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YUluaXRpYWxpemVkKG5vZGU6IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIEJvb2xlYW4obm9kZVtcIl9faW5jcmVtZW50YWxET01EYXRhXCJdKTtcbn1cblxuLyoqXG4gKiBSZWNvcmRzIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSBub2RlIFRoZSBFbGVtZW50IHRoYXQgbWF5IGhhdmUgYXR0cmlidXRlc1xuICogQHBhcmFtIGRhdGEgVGhlIEVsZW1lbnQncyBkYXRhXG4gKi9cbmZ1bmN0aW9uIHJlY29yZEF0dHJpYnV0ZXMobm9kZTogRWxlbWVudCwgZGF0YTogTm9kZURhdGEpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgY29uc3QgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYXR0cnNBcnIgPSBkYXRhLmdldEF0dHJzQXJyKGxlbmd0aCk7XG5cbiAgLy8gVXNlIGEgY2FjaGVkIGxlbmd0aC4gVGhlIGF0dHJpYnV0ZXMgYXJyYXkgaXMgcmVhbGx5IGEgbGl2ZSBOYW1lZE5vZGVNYXAsXG4gIC8vIHdoaWNoIGV4aXN0cyBhcyBhIERPTSBcIkhvc3QgT2JqZWN0XCIgKHByb2JhYmx5IGFzIEMrKyBjb2RlKS4gVGhpcyBtYWtlcyB0aGVcbiAgLy8gdXN1YWwgY29uc3RhbnQgbGVuZ3RoIGl0ZXJhdGlvbiB2ZXJ5IGRpZmZpY3VsdCB0byBvcHRpbWl6ZSBpbiBKSVRzLlxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSwgaiArPSAyKSB7XG4gICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgY29uc3QgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBjb25zdCB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICBhdHRyc0FycltqXSA9IG5hbWU7XG4gICAgYXR0cnNBcnJbaiArIDFdID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBvcnRzIHNpbmdsZSBub2RlIGFuZCBpdHMgc3VidHJlZSwgaW5pdGlhbGl6aW5nIGNhY2hlcywgaWYgaXQgaGFzIG5vdFxuICogYWxyZWFkeSBiZWVuIGltcG9ydGVkLlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gaW1wb3J0LlxuICogQHBhcmFtIGZhbGxiYWNrS2V5IEEga2V5IHRvIHVzZSBpZiBpbXBvcnRpbmcgYW5kIG5vIGtleSB3YXMgc3BlY2lmaWVkLlxuICogICAgVXNlZnVsIHdoZW4gbm90IHRyYW5zbWl0dGluZyBrZXlzIGZyb20gc2VydmVyc2lkZSByZW5kZXIgYW5kIGRvaW5nIGFuXG4gKiAgICBpbW1lZGlhdGUgbm8tb3AgZGlmZi5cbiAqIEByZXR1cm5zIFRoZSBOb2RlRGF0YSBmb3IgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGltcG9ydFNpbmdsZU5vZGUobm9kZTogTm9kZSwgZmFsbGJhY2tLZXk/OiBLZXkpOiBOb2RlRGF0YSB7XG4gIGlmIChub2RlW1wiX19pbmNyZW1lbnRhbERPTURhdGFcIl0pIHtcbiAgICByZXR1cm4gbm9kZVtcIl9faW5jcmVtZW50YWxET01EYXRhXCJdO1xuICB9XG5cbiAgY29uc3Qgbm9kZU5hbWUgPSBpc0VsZW1lbnQobm9kZSkgPyBub2RlLmxvY2FsTmFtZSA6IG5vZGUubm9kZU5hbWU7XG4gIGNvbnN0IGtleUF0dHJOYW1lID0gZ2V0S2V5QXR0cmlidXRlTmFtZSgpO1xuICBjb25zdCBrZXlBdHRyID1cbiAgICBpc0VsZW1lbnQobm9kZSkgJiYga2V5QXR0ck5hbWUgIT0gbnVsbFxuICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZShrZXlBdHRyTmFtZSlcbiAgICAgIDogbnVsbDtcbiAgY29uc3Qga2V5ID0gaXNFbGVtZW50KG5vZGUpID8ga2V5QXR0ciB8fCBmYWxsYmFja0tleSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBpbml0RGF0YShub2RlLCBub2RlTmFtZSwga2V5KTtcblxuICBpZiAoaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgcmVjb3JkQXR0cmlidXRlcyhub2RlLCBkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEltcG9ydHMgbm9kZSBhbmQgaXRzIHN1YnRyZWUsIGluaXRpYWxpemluZyBjYWNoZXMuXG4gKiBAcGFyYW0gbm9kZSBUaGUgTm9kZSB0byBpbXBvcnQuXG4gKi9cbmZ1bmN0aW9uIGltcG9ydE5vZGUobm9kZTogTm9kZSkge1xuICBpbXBvcnRTaW5nbGVOb2RlKG5vZGUpO1xuXG4gIGZvciAoXG4gICAgbGV0IGNoaWxkOiBOb2RlIHwgbnVsbCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICBjaGlsZDtcbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nXG4gICkge1xuICAgIGltcG9ydE5vZGUoY2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBOb2RlRGF0YSBvYmplY3QgZm9yIGEgTm9kZSwgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gZ2V0IGRhdGEgZm9yLlxuICogQHBhcmFtIGZhbGxiYWNrS2V5IEEga2V5IHRvIHVzZSBpZiBpbXBvcnRpbmcgYW5kIG5vIGtleSB3YXMgc3BlY2lmaWVkLlxuICogICAgVXNlZnVsIHdoZW4gbm90IHRyYW5zbWl0dGluZyBrZXlzIGZyb20gc2VydmVyc2lkZSByZW5kZXIgYW5kIGRvaW5nIGFuXG4gKiAgICBpbW1lZGlhdGUgbm8tb3AgZGlmZi5cbiAqIEByZXR1cm5zIFRoZSBOb2RlRGF0YSBmb3IgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldERhdGEobm9kZTogTm9kZSwgZmFsbGJhY2tLZXk/OiBLZXkpIHtcbiAgcmV0dXJuIGltcG9ydFNpbmdsZU5vZGUobm9kZSwgZmFsbGJhY2tLZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGtleSBmb3IgYSBOb2RlLiBub3RlIHRoYXQgdGhlIE5vZGUgc2hvdWxkIGhhdmUgYmVlbiBpbXBvcnRlZFxuICogYnkgbm93LlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUaGUga2V5IHVzZWQgdG8gY3JlYXRlIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRLZXkobm9kZTogTm9kZSkge1xuICBhc3NlcnQobm9kZVtcIl9faW5jcmVtZW50YWxET01EYXRhXCJdKTtcbiAgcmV0dXJuIGdldERhdGEobm9kZSkua2V5O1xufVxuXG4vKipcbiAqIENsZWFycyBhbGwgY2FjaGVzIGZyb20gYSBub2RlIGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIG5vZGUgVGhlIE5vZGUgdG8gY2xlYXIgdGhlIGNhY2hlIGZvci5cbiAqL1xuZnVuY3Rpb24gY2xlYXJDYWNoZShub2RlOiBOb2RlKSB7XG4gIG5vZGVbXCJfX2luY3JlbWVudGFsRE9NRGF0YVwiXSA9IG51bGw7XG5cbiAgZm9yIChcbiAgICBsZXQgY2hpbGQ6IE5vZGUgfCBudWxsID0gbm9kZS5maXJzdENoaWxkO1xuICAgIGNoaWxkO1xuICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmdcbiAgKSB7XG4gICAgY2xlYXJDYWNoZShjaGlsZCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0RGF0YSwgZ2V0S2V5LCBpbml0RGF0YSwgaW1wb3J0Tm9kZSwgaXNEYXRhSW5pdGlhbGl6ZWQsIGNsZWFyQ2FjaGUgfTtcbiJdfQ==