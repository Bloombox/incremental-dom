/**
 * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cached reference to the hasOwnProperty function.
 */
const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * A constructor function that will create blank objects.
 */
function Blank() { }
Blank.prototype = Object.create(null);
/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param map The map to check.
 * @param property The property to check.
 * @return Whether map has property.
 */
function has(map, property) {
    return hasOwnProperty.call(map, property);
}
/**
 * Creates an map object without a prototype.
 * @returns An Object that can be used as a map.
 */
function createMap() {
    return new Blank();
}
/**
 * Truncates an array, removing items up until length.
 * @param arr The array to truncate.
 * @param length The new length of the array.
 */
function truncateArray(arr, length) {
    while (arr.length > length) {
        arr.pop();
    }
}
/**
 * Creates an array for a desired initial size. Note that the array will still
 * be empty.
 * @param initialAllocationSize The initial size to allocate.
 * @returns An empty array, with an initial allocation for the desired size.
 */
function createArray(initialAllocationSize) {
    const arr = new Array(initialAllocationSize);
    truncateArray(arr, 0);
    return arr;
}
export { createArray, createMap, has, truncateArray };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3JlbGVhc2UvdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUVIOztHQUVHO0FBQ0gsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7QUFFdkQ7O0dBRUc7QUFDSCxTQUFTLEtBQUssS0FBSSxDQUFDO0FBRW5CLEtBQUssQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUV0Qzs7Ozs7R0FLRztBQUNILFNBQVMsR0FBRyxDQUFDLEdBQVcsRUFBRSxRQUFnQjtJQUN4QyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLFNBQVM7SUFDaEIsT0FBTyxJQUFLLEtBQWEsRUFBRSxDQUFDO0FBQzlCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxhQUFhLENBQUMsR0FBaUMsRUFBRSxNQUFjO0lBQ3RFLE9BQU8sR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUU7UUFDMUIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ1g7QUFDSCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLFdBQVcsQ0FBSSxxQkFBNkI7SUFDbkQsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUM3QyxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RCLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTggVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGhhc093blByb3BlcnR5IGZ1bmN0aW9uLlxuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgY3JlYXRlIGJsYW5rIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIEJsYW5rKCkge31cblxuQmxhbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBVc2VkIHRvIHByZXZlbnQgcHJvcGVydHkgY29sbGlzaW9ucyBiZXR3ZWVuIG91ciBcIm1hcFwiIGFuZCBpdHMgcHJvdG90eXBlLlxuICogQHBhcmFtIG1hcCBUaGUgbWFwIHRvIGNoZWNrLlxuICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAqIEByZXR1cm4gV2hldGhlciBtYXAgaGFzIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBoYXMobWFwOiBvYmplY3QsIHByb3BlcnR5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwobWFwLCBwcm9wZXJ0eSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBtYXAgb2JqZWN0IHdpdGhvdXQgYSBwcm90b3R5cGUuXG4gKiBAcmV0dXJucyBBbiBPYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIG1hcC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFwKCk6IGFueSB7XG4gIHJldHVybiBuZXcgKEJsYW5rIGFzIGFueSkoKTtcbn1cblxuLyoqXG4gKiBUcnVuY2F0ZXMgYW4gYXJyYXksIHJlbW92aW5nIGl0ZW1zIHVwIHVudGlsIGxlbmd0aC5cbiAqIEBwYXJhbSBhcnIgVGhlIGFycmF5IHRvIHRydW5jYXRlLlxuICogQHBhcmFtIGxlbmd0aCBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRydW5jYXRlQXJyYXkoYXJyOiBBcnJheTx7fSB8IG51bGwgfCB1bmRlZmluZWQ+LCBsZW5ndGg6IG51bWJlcikge1xuICB3aGlsZSAoYXJyLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIGFyci5wb3AoKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgZm9yIGEgZGVzaXJlZCBpbml0aWFsIHNpemUuIE5vdGUgdGhhdCB0aGUgYXJyYXkgd2lsbCBzdGlsbFxuICogYmUgZW1wdHkuXG4gKiBAcGFyYW0gaW5pdGlhbEFsbG9jYXRpb25TaXplIFRoZSBpbml0aWFsIHNpemUgdG8gYWxsb2NhdGUuXG4gKiBAcmV0dXJucyBBbiBlbXB0eSBhcnJheSwgd2l0aCBhbiBpbml0aWFsIGFsbG9jYXRpb24gZm9yIHRoZSBkZXNpcmVkIHNpemUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5PFQ+KGluaXRpYWxBbGxvY2F0aW9uU2l6ZTogbnVtYmVyKTogQXJyYXk8VD4ge1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaW5pdGlhbEFsbG9jYXRpb25TaXplKTtcbiAgdHJ1bmNhdGVBcnJheShhcnIsIDApO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgeyBjcmVhdGVBcnJheSwgY3JlYXRlTWFwLCBoYXMsIHRydW5jYXRlQXJyYXkgfTtcbiJdfQ==