/**
 * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cached reference to the hasOwnProperty function.
 */
const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * A constructor function that will create blank objects.
 */
function Blank() { }
Blank.prototype = Object.create(null);
/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param map The map to check.
 * @param property The property to check.
 * @return Whether map has property.
 */
function has(map, property) {
    return hasOwnProperty.call(map, property);
}
/**
 * Creates an map object without a prototype.
 * @returns An Object that can be used as a map.
 */
function createMap() {
    return new Blank();
}
/**
 * Truncates an array, removing items up until length.
 * @param arr The array to truncate.
 * @param length The new length of the array.
 */
function truncateArray(arr, length) {
    while (arr.length > length) {
        arr.pop();
    }
}
/**
 * Creates an array for a desired initial size. Note that the array will still
 * be empty.
 * @param initialAllocationSize The initial size to allocate.
 * @returns An empty array, with an initial allocation for the desired size.
 */
function createArray(initialAllocationSize) {
    const arr = new Array(initialAllocationSize);
    truncateArray(arr, 0);
    return arr;
}
export { createArray, createMap, has, truncateArray };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBRUg7O0dBRUc7QUFDSCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztBQUV2RDs7R0FFRztBQUNILFNBQVMsS0FBSyxLQUFJLENBQUM7QUFFbkIsS0FBSyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBRXRDOzs7OztHQUtHO0FBQ0gsU0FBUyxHQUFHLENBQUMsR0FBVyxFQUFFLFFBQWdCO0lBQ3hDLE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsU0FBUztJQUNoQixPQUFPLElBQUssS0FBYSxFQUFFLENBQUM7QUFDOUIsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGFBQWEsQ0FBQyxHQUFpQyxFQUFFLE1BQWM7SUFDdEUsT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtRQUMxQixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDWDtBQUNILENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQVMsV0FBVyxDQUFJLHFCQUE2QjtJQUNuRCxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQzdDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEIsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgY2FjaGVkIHJlZmVyZW5jZSB0byB0aGUgaGFzT3duUHJvcGVydHkgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgd2lsbCBjcmVhdGUgYmxhbmsgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gQmxhbmsoKSB7fVxuXG5CbGFuay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIFVzZWQgdG8gcHJldmVudCBwcm9wZXJ0eSBjb2xsaXNpb25zIGJldHdlZW4gb3VyIFwibWFwXCIgYW5kIGl0cyBwcm90b3R5cGUuXG4gKiBAcGFyYW0gbWFwIFRoZSBtYXAgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICogQHJldHVybiBXaGV0aGVyIG1hcCBoYXMgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGhhcyhtYXA6IG9iamVjdCwgcHJvcGVydHk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG1hcCBvYmplY3Qgd2l0aG91dCBhIHByb3RvdHlwZS5cbiAqIEByZXR1cm5zIEFuIE9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgbWFwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXAoKTogYW55IHtcbiAgcmV0dXJuIG5ldyAoQmxhbmsgYXMgYW55KSgpO1xufVxuXG4vKipcbiAqIFRydW5jYXRlcyBhbiBhcnJheSwgcmVtb3ZpbmcgaXRlbXMgdXAgdW50aWwgbGVuZ3RoLlxuICogQHBhcmFtIGFyciBUaGUgYXJyYXkgdG8gdHJ1bmNhdGUuXG4gKiBAcGFyYW0gbGVuZ3RoIFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdHJ1bmNhdGVBcnJheShhcnI6IEFycmF5PHt9IHwgbnVsbCB8IHVuZGVmaW5lZD4sIGxlbmd0aDogbnVtYmVyKSB7XG4gIHdoaWxlIChhcnIubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgYXJyLnBvcCgpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBmb3IgYSBkZXNpcmVkIGluaXRpYWwgc2l6ZS4gTm90ZSB0aGF0IHRoZSBhcnJheSB3aWxsIHN0aWxsXG4gKiBiZSBlbXB0eS5cbiAqIEBwYXJhbSBpbml0aWFsQWxsb2NhdGlvblNpemUgVGhlIGluaXRpYWwgc2l6ZSB0byBhbGxvY2F0ZS5cbiAqIEByZXR1cm5zIEFuIGVtcHR5IGFycmF5LCB3aXRoIGFuIGluaXRpYWwgYWxsb2NhdGlvbiBmb3IgdGhlIGRlc2lyZWQgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXk8VD4oaW5pdGlhbEFsbG9jYXRpb25TaXplOiBudW1iZXIpOiBBcnJheTxUPiB7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpbml0aWFsQWxsb2NhdGlvblNpemUpO1xuICB0cnVuY2F0ZUFycmF5KGFyciwgMCk7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUFycmF5LCBjcmVhdGVNYXAsIGhhcywgdHJ1bmNhdGVBcnJheSB9O1xuIl19